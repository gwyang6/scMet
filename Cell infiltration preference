# Define a function called test.dist.table to perform statistical tests on the input distance table
test.dist.table <- function(count.dist, min.rowSum = 0) {
  # Remove rows with row sums less than min.rowSum
  count.dist <- count.dist[rowSums(count.dist) >= min.rowSum, , drop = FALSE]
  
  # Calculate column sums and row sums of the distance table
  sum.col <- colSums(count.dist)
  sum.row <- rowSums(count.dist)
  
  # Convert the count distance table to a data frame
  count.dist.tb <- as.data.frame(count.dist)
  
  # Set row names as a separate column in the data frame
  setDT(count.dist.tb, keep.rownames = TRUE)
  
  # Reshape the count distance table using the melt function
  count.dist.melt.tb <- melt(count.dist.tb, id.vars = "rn")
  colnames(count.dist.melt.tb) <- c("rid", "cid", "count")
  
  # Perform Fisher's exact test for each row in the melted data frame
  count.dist.melt.ext.tb <- as.data.table(ldply(seq_len(nrow(count.dist.melt.tb)), function(i) {
    this.row <- count.dist.melt.tb$rid[i]
    this.col <- count.dist.melt.tb$cid[i]
    this.c <- count.dist.melt.tb$count[i]
    other.col.c <- sum.col[this.col] - this.c
    this.m <- matrix(c(this.c, sum.row[this.row] - this.c, other.col.c, sum(sum.col) - sum.row[this.row] - other.col.c), ncol = 2)
    res.test <- fisher.test(this.m)
    data.frame(rid = this.row, cid = this.col, p.value = res.test$p.value, OR = res.test$estimate)
  }))
  
  # Merge the original melted data frame with the results of Fisher's exact test
  count.dist.melt.ext.tb <- merge(count.dist.melt.tb, count.dist.melt.ext.tb, by = c("rid", "cid"))
  
  # Calculate adjusted p-values using the Benjamini-Hochberg method
  count.dist.melt.ext.tb[, adj.p.value := p.adjust(p.value, "BH")]
  
  return(count.dist.melt.ext.tb)
}

# Extract cell information from the Macrophage metadata and create a data table
cellInfo.tb <- data.table(Seurat@meta.data)
# Extract metadata information for meta.cluster and loc
meta.cluster <- cellInfo.tb$anno
loc <- cellInfo.tb$region

# Convert meta.cluster to character and loc to factor
cellInfo.tb <- data.table(cellInfo.tb)
cellInfo.tb$meta.cluster <- as.character(meta.cluster)
cellInfo.tb$loc <- as.factor(loc)

# Get available locations from the loc column
loc.avai.vec <- levels(cellInfo.tb[["loc"]])

# Create count distance table and frequency distribution table
count.dist <- unclass(cellInfo.tb[, table(meta.cluster, loc)])[, loc.avai.vec]
freq.dist <- sweep(count.dist, 1, rowSums(count.dist), "/")
freq.dist.bin <- floor(freq.dist * 100 / 10)
print(freq.dist.bin)

# Call the test.dist.table function on the count distance table to get p-values and odds ratios
count.dist.melt.ext.tb <- test.dist.table(count.dist)
p.dist.tb <- dcast(count.dist.melt.ext.tb, rid ~ cid, value.var = "p.value")
OR.dist.tb <- dcast(count.dist.melt.ext.tb, rid ~ cid, value.var = "OR")
OR.dist.mtx <- as.matrix(OR.dist.tb[, -1])
rownames(OR.dist.mtx) <- OR.dist.tb[[1]]

# Result
OR.dist.mtx
p.dist.tb

start_color <- "#440154"
mid_color <- "#3C4E88"
end_color <- "#5EC462"
final_color <- "#FDE725"
color_gradient <- colorRampPalette(c(start_color, mid_color, end_color, final_color))
gradient_colors <- color_gradient(100)
pheatmap(t(OR.dist.mtx), cluster_rows = F, cluster_cols = F, col =colorRampPalette(c("#3288BD", "white", "#D53E4F" ))(50),scale = 'row')


